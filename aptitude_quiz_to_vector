#%%
from typing import List, Dict, Tuple, Iterable, Optional
from collections import defaultdict
import pandas as pd

# ---------------------------------
# Scoring & Category Configuration
# ---------------------------------

LIKERT_MAP = {
    "strongly disagree": 1,
    "disagree": 2,
    "neutral": 3,
    "agree": 4,
    "strongly agree": 5,
}

# Fixed category order => vector order
CATEGORIES = [
    "Digital Fundamentals",
    "Online Safety",
    "AI & Technology",
    "Communication",
    "Problem Solving",
    "Creativity",
    "Data Skills",
    "Career Readiness",
]

# Recommendations mapping for top-2 categories (unordered pairs handled later)
RECOMMENDATION_MAP = {
    frozenset(["Communication", "Career Readiness"]): [
        "Customer Support/BPO", "Sales Associate", "Community Coordinator"
    ],
    frozenset(["Creativity", "Digital Fundamentals"]): [
        "Social Media Content Creator", "Graphic Designer/Video Editor (entry)", "Digital Marketing Intern"
    ],
    frozenset(["Data Skills", "Problem Solving"]): [
        "Data Entry/Operations Executive", "Jr. Data Analyst Trainee", "Quality Analyst"
    ],
    frozenset(["Online Safety", "Digital Fundamentals"]): [
        "IT Support/Helpdesk Trainee", "Cybersecurity Awareness Ambassador"
    ],
    frozenset(["AI & Technology", "Creativity"]): [
        "AI Operations/Prompting Assistant (ChatGPT/Meta AI)", "Data Labeling/AI Content Reviewer", "Chatbot Support"
    ],
}

# Fallbacks when no specific pair mapping found
FALLBACK_BY_TOP = {
    "Digital Fundamentals": ["IT Support Trainee", "Operations Assistant"],
    "Online Safety": ["Security Awareness Ambassador", "Service Desk Trainee"],
    "AI & Technology": ["AI Ops Assistant", "Data Labeling Associate"],
    "Communication": ["Customer Support", "Front Desk Associate"],
    "Problem Solving": ["Quality Analyst", "Tech Support"],
    "Creativity": ["Content Creator", "Design Intern"],
    "Data Skills": ["Data Entry/Operations", "Reporting Assistant"],
    "Career Readiness": ["Office Admin", "Program Assistant"],
}

# -----------------------------
# Core Scoring Functions
# -----------------------------

def normalize_likert(answer: str) -> int:
    """
    Convert a Likert string to numeric 1..5. Unknown -> 3 (neutral).
    Accepts case-insensitive text or "1"/"2"/... as strings.
    """
    if answer is None:
        return 3
    s = str(answer).strip().lower()
    if s.isdigit() and s in {"1","2","3","4","5"}:
        return int(s)
    return LIKERT_MAP.get(s, 3)

def validate_inputs(questions: List[Dict], answers: List[str], mcq_key: Dict[int, str]) -> None:
    if len(questions) != len(answers):
        raise ValueError(f"questions ({len(questions)}) and answers ({len(answers)}) length mismatch.")
    for idx, q in enumerate(questions):
        if q.get("type","").lower() == "mcq" and idx not in mcq_key:
            raise ValueError(f"Missing MCQ key for question index {idx}.")

def compute_category_maxima(questions: List[Dict]) -> Dict[str, Tuple[int, int]]:
    cat_likert_counts = defaultdict(int)
    cat_mcq_counts = defaultdict(int)
    for q in questions:
        cat = q["category"]
        if q["type"].lower() == "likert":
            cat_likert_counts[cat] += 1
        elif q["type"].lower() == "mcq":
            cat_mcq_counts[cat] += 1
    maxima = {}
    for cat in CATEGORIES:
        maxima[cat] = (cat_likert_counts[cat] * 5, cat_mcq_counts[cat] * 1)
    return maxima

def score_student(
    questions: List[Dict],
    answers: List[str],
    mcq_key: Dict[int, str],
) -> List[float]:
    """
    Returns an 8-element vector of proficiencies (0..1) in the fixed CATEGORIES order.
    questions: list of dicts -> {"category": <str>, "type": "likert"|"mcq"}
    answers: list of strings -> Likert text or "A"/"B"/"C"/"D"
    mcq_key: dict {question_index: "A"/"B"/"C"/"D"}
    """
    validate_inputs(questions, answers, mcq_key)

    cat_likert_sum = defaultdict(int)
    cat_mcq_sum = defaultdict(int)

    for idx, (q, ans) in enumerate(zip(questions, answers)):
        cat = q["category"]
        qtype = q["type"].lower()

        if qtype == "likert":
            cat_likert_sum[cat] += normalize_likert(ans)
        elif qtype == "mcq":
            correct = str(mcq_key[idx]).strip().upper()
            given = str(ans).strip().upper()
            cat_mcq_sum[cat] += 1 if given == correct else 0
        else:
            raise ValueError(f"Unknown question type at index {idx}: {qtype}")

    maxima = compute_category_maxima(questions)

    prof_vector = []
    for cat in CATEGORIES:
        max_likert, max_mcq = maxima[cat]
        total_max = max_likert + max_mcq
        if total_max == 0:
            prof_vector.append(0.0)
            continue
        total_score = cat_likert_sum[cat] + cat_mcq_sum[cat]
        total_score = max(0, min(total_score, total_max))
        prof_vector.append(total_score / total_max)
    return prof_vector

# -----------------------------
# Recommendations
# -----------------------------

def top2_categories_from_vector(prof_vector: List[float]) -> Tuple[str, str]:
    """
    Returns the names of the top-2 categories based on the prof_vector.
    Ties are broken by category order.
    """
    pairs = sorted(
        [(CATEGORIES[i], v) for i, v in enumerate(prof_vector)],
        key=lambda x: (-x[1], CATEGORIES.index(x[0])),
    )
    return pairs[0][0], pairs[1][0]

def recommend_roles(top1: str, top2: str) -> List[str]:
    key = frozenset([top1, top2])
    if key in RECOMMENDATION_MAP:
        return RECOMMENDATION_MAP[key]
    # fallback: use top1's generic suggestion
    return FALLBACK_BY_TOP.get(top1, ["General Trainee", "Assistant"])

# -----------------------------
# Batch API
# -----------------------------

def batch_score(
    questions: List[Dict],
    mcq_key: Dict[int, str],
    student_records: Iterable[Dict],
    answer_field: str = "answers",
    id_field: Optional[str] = "student_id",
    export_path: Optional[str] = None,   # e.g., "scores.csv" or "scores.xlsx"
) -> pd.DataFrame:
    """
    Batch score many students.
    Params:
      - questions: same structure as single-student
      - mcq_key:   dict of correct options for MCQs
      - student_records: iterable of dicts, each with:
            {
               "student_id": "...",   # optional but recommended
               "answers": [str, str, ... 24 items ...]
            }
        If your dict uses different keys, change `answer_field` / `id_field`.
      - answer_field: key containing the list of 24 answers
      - id_field:     key used as the identifier column in output (can be None)
      - export_path:  if provided, writes CSV or XLSX based on extension

    Returns:
      Pandas DataFrame with:
        [student_id], per-category columns (0..1), top1, top2, recommendation, and the vector column.
    """
    # Precompute category maxima once (also validates structure)
    # Use a dummy neutral student just to validate
    dummy_answers = ["neutral" if q["type"].lower()=="likert" else "A" for q in questions]
    validate_inputs(questions, dummy_answers, mcq_key)

    rows = []
    for rec in student_records:
        answers = rec.get(answer_field, [])
        if len(answers) != len(questions):
            raise ValueError(f"Student record has {len(answers)} answers, expected {len(questions)}.")
        vec = score_student(questions, answers, mcq_key)
        top1, top2 = top2_categories_from_vector(vec)
        roles = recommend_roles(top1, top2)

        row = {}
        if id_field is not None:
            row[id_field] = rec.get(id_field, None)

        # Per-category columns
        for cat, val in zip(CATEGORIES, vec):
            row[cat] = float(f"{val:.6f}")  # stable numeric

        row["top1"] = top1
        row["top2"] = top2
        row["recommendations"] = "; ".join(roles)
        row["vector"] = vec  # keep original list for easy programmatic use
        rows.append(row)

    df = pd.DataFrame(rows)

    if export_path:
        if export_path.lower().endswith(".csv"):
            df.to_csv(export_path, index=False)
        elif export_path.lower().endswith(".xlsx"):
            # Ensure openpyxl is available in your environment
            df.to_excel(export_path, index=False, engine="openpyxl")
        else:
            raise ValueError("export_path must end with .csv or .xlsx")

    return df

# -----------------------------
# Quick Example (edit freely)
# -----------------------------
if __name__ == "__main__":
    # Build 24-question config: for each category, 2 likert + 1 mcq
    quiz_questions = []
    for cat in CATEGORIES:
        quiz_questions.append({"category": cat, "type": "likert"})
        quiz_questions.append({"category": cat, "type": "likert"})
        quiz_questions.append({"category": cat, "type": "mcq"})

    # MCQ answer key aligned with our earlier quiz (indices 2,5,8,11,14,17,20,23)
    mcq_answer_key = {
        2:  "B",  # Q3
        5:  "A",  # Q6
        8:  "C",  # Q9
        11: "C",  # Q12
        14: "B",  # Q15
        17: "C",  # Q18
        20: "B",  # Q21
        23: "C",  # Q24
    }

    # Example batch: three students (IDs + 24 answers each)
    batch = [
        {
            "student_id": "S001",
            "answers": [
                "agree","strongly agree","B",
                "neutral","agree","A",
                "disagree","agree","C",
                "agree","agree","C",
                "neutral","neutral","B",
                "strongly agree","agree","C",
                "agree","neutral","B",
                "agree","strongly agree","C",
            ],
        },
        {
            "student_id": "S002",
            "answers": [
                "disagree","neutral","B",
                "agree","agree","A",
                "agree","agree","C",
                "agree","neutral","C",
                "agree","agree","B",
                "agree","agree","C",
                "strongly agree","agree","B",
                "neutral","agree","C",
            ],
        },
        {
            "student_id": "S003",
            "answers": [
                "neutral","neutral","D",
                "disagree","neutral","C",
                "neutral","neutral","D",
                "agree","neutral","D",
                "neutral","neutral","A",
                "agree","neutral","B",
                "neutral","neutral","C",
                "disagree","neutral","A",
            ],
        },
    ]

    df = batch_score(
        questions=quiz_questions,
        mcq_key=mcq_answer_key,
        student_records=batch,
        answer_field="answers",
        id_field="student_id",
        export_path="proficiency_scores.csv",    # <- enable to export CSV
        # export_path="proficiency_scores.xlsx",   # <- or export Excel
    )

    # Pretty print (optional)
    with pd.option_context('display.max_columns', None, 'display.width', 140):
        print(df)